/**
 * Agent Runner
 *
 * Executes task with AI agent and generates code/PR
 * In TEST mode: deterministic mock output
 * In PROD mode: real AI integration (future)
 */

import { AgentConfig } from "./registry";
import { TaskInfo } from "./agent-selector";

export interface AgentRunResult {
  success: boolean;
  generatedCode: string;
  commitMessage: string;
  prTitle: string;
  prDescription: string;
  prNumber?: number;
  error?: string;
}

export interface ProjectContext {
  projectId: string;
  projectName: string;
  existingFiles?: string[];
}

/**
 * Check if running in test mode
 */
function isTestMode(): boolean {
  return process.env.PLAYWRIGHT === "1" || process.env.NODE_ENV === "test";
}

/**
 * Generate deterministic hash from string (for test mode)
 */
function hashString(str: string): number {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = (hash << 5) - hash + char;
    hash = hash & hash;
  }
  return Math.abs(hash);
}

/**
 * Generate deterministic PR number based on task ID
 */
function generatePRNumber(taskId: string): number {
  const hash = hashString(taskId);
  return 100 + (hash % 900);
}

/**
 * Generate mock code output (deterministic for tests)
 */
function generateMockCode(task: TaskInfo, agent: AgentConfig): string {
  const header = `// Generated by ${agent.name}\n// Task: ${task.title}\n\n`;

  switch (agent.role) {
    case "backend":
      return `${header}import { NextRequest, NextResponse } from "next/server";

export async function POST(request: NextRequest) {
  const body = await request.json();
  // TODO: Implement ${task.title}
  return NextResponse.json({ success: true });
}`;

    case "frontend":
      return `${header}"use client";

import { Button } from "@/components/ui/button";

export function GeneratedComponent() {
  return <Button>Click Me</Button>;
}`;

    case "qa":
      return `${header}import { test, expect } from '@playwright/test';

test('${task.title}', async ({ page }) => {
  await page.goto('/');
  await expect(page).toHaveTitle(/Vibe Kanban/);
});`;

    case "architect":
      return `${header}/**
 * Architecture: ${task.title}
 * - Modular design
 * - SOLID principles
 */

export interface DesignPattern {
  pattern: string;
}`;

    default:
      return `${header}// Implementation`;
  }
}

/**
 * Generate commit message
 */
function generateCommitMessage(task: TaskInfo, agent: AgentConfig): string {
  const prefix = agent.role === "qa" ? "test" : agent.role === "frontend" ? "feat" : "feat";
  return `${prefix}: ${task.title}\n\nGenerated by ${agent.name}\n\nðŸ¤– AI-generated commit`;
}

/**
 * Generate PR title
 */
function generatePRTitle(task: TaskInfo): string {
  return `[AI] ${task.title}`;
}

/**
 * Generate PR description
 */
function generatePRDescription(task: TaskInfo, agent: AgentConfig): string {
  return `## Summary
${task.description}

## Changes
- Implemented ${task.title}
- Added necessary files and tests
- Followed project conventions

## Testing
- [ ] Manual testing completed
- [ ] All tests passing
- [ ] Code review requested

---
ðŸ¤– Generated by ${agent.name}`;
}

/**
 * Run agent on task
 *
 * In TEST mode: generates deterministic mock output
 * In PROD mode: would call real AI service
 */
export async function runAgent(
  task: TaskInfo,
  agent: AgentConfig,
  context: ProjectContext
): Promise<AgentRunResult> {
  try {
    if (isTestMode()) {
      // Test mode: deterministic mock output
      const generatedCode = generateMockCode(task, agent);
      const commitMessage = generateCommitMessage(task, agent);
      const prTitle = generatePRTitle(task);
      const prDescription = generatePRDescription(task, agent);
      const prNumber = generatePRNumber(task.id);

      return {
        success: true,
        generatedCode,
        commitMessage,
        prTitle,
        prDescription,
        prNumber,
      };
    }

    // Production mode: real AI integration
    // TODO: Implement OpenAI/Claude API call
    // For MVP, we'll use the same mock output
    const generatedCode = generateMockCode(task, agent);
    const commitMessage = generateCommitMessage(task, agent);
    const prTitle = generatePRTitle(task);
    const prDescription = generatePRDescription(task, agent);

    return {
      success: true,
      generatedCode,
      commitMessage,
      prTitle,
      prDescription,
    };
  } catch (error: any) {
    return {
      success: false,
      generatedCode: "",
      commitMessage: "",
      prTitle: "",
      prDescription: "",
      error: error.message || "Agent execution failed",
    };
  }
}
