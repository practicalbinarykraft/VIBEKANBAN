import { NextRequest, NextResponse } from "next/server";
import { db } from "@/server/db";
import { attempts, tasks, projects } from "@/server/db/schema";
import { eq } from "drizzle-orm";
import { createPullRequest, parseGitHubUrl } from "@/server/services/github-client";
import { getCurrentUserId, canPerformTaskAction, permissionDeniedError } from "@/server/services/permissions";

/**
 * POST /api/attempts/:id/create-pr
 *
 * Creates a GitHub PR for the attempt's branch
 * In test mode (PLAYWRIGHT=1), mocks PR creation with fixture data
 * In production, calls real GitHub API to create PR
 */
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id: attemptId } = await params;

  try {
    // Get attempt
    const attempt = await db
      .select()
      .from(attempts)
      .where(eq(attempts.id, attemptId))
      .get();

    if (!attempt) {
      return NextResponse.json({ error: "Attempt not found" }, { status: 404 });
    }

    // Check permissions
    const userId = await getCurrentUserId(request);
    const canPerform = await canPerformTaskAction(attempt.taskId, userId);
    if (!canPerform) {
      return NextResponse.json(permissionDeniedError(), { status: 403 });
    }

    // Validate attempt is completed
    if (attempt.status !== "completed") {
      return NextResponse.json(
        { error: "Can only create PR for completed attempts" },
        { status: 400 }
      );
    }

    // Check if PR already exists
    if (attempt.prUrl) {
      return NextResponse.json(
        { error: "PR already exists", prUrl: attempt.prUrl, prNumber: attempt.prNumber },
        { status: 400 }
      );
    }

    // Validate we have a branch
    if (!attempt.branchName || !attempt.headCommit) {
      return NextResponse.json(
        { error: "No branch to create PR from" },
        { status: 400 }
      );
    }

    // In test mode (PLAYWRIGHT=1), mock PR creation
    const isTestMode = process.env.PLAYWRIGHT === "1";

    let prNumber: number;
    let prUrl: string;
    let prStatus: 'open' | 'merged' | 'closed' = 'open';

    if (isTestMode) {
      // Mock PR creation for tests (keeps E2E tests deterministic)
      prNumber = 42;
      prUrl = "https://github.com/test-org/test-repo/pull/42";
      prStatus = 'open';
    } else {
      // Production: Real GitHub API integration
      // Get task to access project
      const task = await db
        .select()
        .from(tasks)
        .where(eq(tasks.id, attempt.taskId))
        .get();

      if (!task) {
        return NextResponse.json(
          { error: "Task not found" },
          { status: 404 }
        );
      }

      // Get project to access gitUrl
      const project = await db
        .select()
        .from(projects)
        .where(eq(projects.id, task.projectId))
        .get();

      if (!project) {
        return NextResponse.json(
          { error: "Project not found" },
          { status: 404 }
        );
      }

      // Parse GitHub URL to extract owner and repo
      let repoOwner: string;
      let repoName: string;
      try {
        const parsed = parseGitHubUrl(project.gitUrl);
        repoOwner = parsed.owner;
        repoName = parsed.repo;
      } catch (error: any) {
        return NextResponse.json(
          { error: `Invalid GitHub URL: ${error.message}` },
          { status: 400 }
        );
      }

      // Create PR via GitHub API
      try {
        const prResult = await createPullRequest({
          repoOwner,
          repoName,
          head: attempt.branchName,
          base: attempt.baseBranch || project.defaultBranch,
          title: `[AI Agent] ${task.title}`,
          body: `Automated changes for task: ${task.title}\n\n${task.description}\n\n---\nðŸ¤– Generated by Vibe Kanban AI Agent`,
        });

        prNumber = prResult.number;
        prUrl = prResult.url;
        prStatus = prResult.state;
      } catch (error: any) {
        // Return GitHub API errors with proper context
        return NextResponse.json(
          { error: `Failed to create PR: ${error.message}` },
          { status: 500 }
        );
      }
    }

    // Update attempt with PR info
    await db.update(attempts)
      .set({
        prNumber,
        prUrl,
        prStatus,
      })
      .where(eq(attempts.id, attemptId));

    return NextResponse.json({
      success: true,
      prNumber,
      prUrl,
      prStatus,
    });

  } catch (error: any) {
    console.error("Error creating PR:", error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}
